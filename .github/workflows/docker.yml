# ΣLANG Docker Build & Publish Workflow
# Builds multi-architecture Docker images and pushes to GitHub Container Registry (GHCR)

name: Docker

on:
    push:
        branches: [main]
        tags: ["v*.*.*"]
    pull_request:
        branches: [main]
    workflow_dispatch:
        inputs:
            push:
                description: "Push images to registry"
                required: false
                default: "false"
                type: boolean

env:
    REGISTRY: ghcr.io
    IMAGE_NAME: ${{ github.repository }}

jobs:
    # Build and test Docker image
    build:
        runs-on: ubuntu-latest
        permissions:
            contents: read
            packages: write
            id-token: write # For signing with cosign

        outputs:
            image-digest: ${{ steps.build.outputs.digest }}
            image-tags: ${{ steps.meta.outputs.tags }}

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4

            - name: Set up QEMU
              uses: docker/setup-qemu-action@v3

            - name: Set up Docker Buildx
              uses: docker/setup-buildx-action@v3
              with:
                  driver-opts: |
                      image=moby/buildkit:master
                      network=host

            # Extract metadata for Docker
            - name: Extract Docker metadata
              id: meta
              uses: docker/metadata-action@v5
              with:
                  images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
                  tags: |
                      # Branch builds
                      type=ref,event=branch
                      # PR builds
                      type=ref,event=pr
                      # Semantic versioning from tags
                      type=semver,pattern={{version}}
                      type=semver,pattern={{major}}.{{minor}}
                      type=semver,pattern={{major}}
                      # SHA for traceability
                      type=sha,prefix=sha-,format=short
                      # Latest tag for main branch
                      type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
                  labels: |
                      org.opencontainers.image.title=ΣLANG
                      org.opencontainers.image.description=Advanced Neural Semantic Compression Language
                      org.opencontainers.image.vendor=ΣLANG Project
                      org.opencontainers.image.licenses=MIT

            # Login to GHCR (skip for PRs from forks)
            - name: Log in to Container Registry
              if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
              uses: docker/login-action@v3
              with:
                  registry: ${{ env.REGISTRY }}
                  username: ${{ github.actor }}
                  password: ${{ secrets.GITHUB_TOKEN }}

            # Build and optionally push
            - name: Build and push Docker image
              id: build
              uses: docker/build-push-action@v5
              with:
                  context: .
                  file: ./Dockerfile
                  platforms: linux/amd64,linux/arm64
                  push: ${{ github.event_name != 'pull_request' }}
                  tags: ${{ steps.meta.outputs.tags }}
                  labels: ${{ steps.meta.outputs.labels }}
                  cache-from: type=gha
                  cache-to: type=gha,mode=max
                  build-args: |
                      BUILD_DATE=${{ github.event.head_commit.timestamp }}
                      VCS_REF=${{ github.sha }}
                      VERSION=${{ steps.meta.outputs.version }}

            # Sign the image with cosign (production only)
            - name: Install cosign
              if: github.event_name != 'pull_request' && startsWith(github.ref, 'refs/tags/v')
              uses: sigstore/cosign-installer@v3

            - name: Sign the container image
              if: github.event_name != 'pull_request' && startsWith(github.ref, 'refs/tags/v')
              env:
                  COSIGN_EXPERIMENTAL: "true"
              run: |
                  echo "${{ steps.build.outputs.digest }}" | xargs -I {} cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@{}

    # Test the built image
    test:
        runs-on: ubuntu-latest
        needs: build
        if: github.event_name != 'pull_request'

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4

            - name: Pull and test image
              run: |
                  # Pull the image
                  docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-$(echo ${{ github.sha }} | cut -c1-7)

                  # Test image size (should be < 500MB)
                  IMAGE_SIZE=$(docker image inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-$(echo ${{ github.sha }} | cut -c1-7) --format='{{.Size}}')
                  IMAGE_SIZE_MB=$((IMAGE_SIZE / 1024 / 1024))
                  echo "Image size: ${IMAGE_SIZE_MB}MB"
                  if [ $IMAGE_SIZE_MB -gt 500 ]; then
                    echo "::warning::Image size exceeds 500MB target: ${IMAGE_SIZE_MB}MB"
                  fi

            - name: Test container startup
              run: |
                  # Start container
                  CONTAINER_ID=$(docker run -d \
                    -p 8000:8000 \
                    -e SIGMALANG_ENV=test \
                    ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-$(echo ${{ github.sha }} | cut -c1-7))

                  # Wait for startup (max 30s)
                  START_TIME=$(date +%s)
                  MAX_WAIT=30
                  while ! curl -sf http://localhost:8000/health > /dev/null 2>&1; do
                    sleep 1
                    CURRENT_TIME=$(date +%s)
                    ELAPSED=$((CURRENT_TIME - START_TIME))
                    if [ $ELAPSED -gt $MAX_WAIT ]; then
                      echo "Container failed to start within ${MAX_WAIT}s"
                      docker logs $CONTAINER_ID
                      exit 1
                    fi
                  done

                  STARTUP_TIME=$(($(date +%s) - START_TIME))
                  echo "Container started in ${STARTUP_TIME}s"

                  # Verify startup time target
                  if [ $STARTUP_TIME -gt 5 ]; then
                    echo "::warning::Startup time exceeds 5s target: ${STARTUP_TIME}s"
                  fi

            - name: Run health check
              run: |
                  # Health endpoint
                  curl -sf http://localhost:8000/health | jq .

                  # Ready endpoint
                  curl -sf http://localhost:8000/ready | jq .

                  # Metrics endpoint
                  curl -sf http://localhost:8000/metrics | head -20

            - name: Run API smoke tests
              run: |
                  # Test encode endpoint
                  ENCODE_RESPONSE=$(curl -sf -X POST http://localhost:8000/api/v1/encode \
                    -H "Content-Type: application/json" \
                    -d '{"text": "Hello, ΣLANG!", "config": {"quality": "balanced"}}')
                  echo "Encode response: $ENCODE_RESPONSE"

                  # Extract encoded data
                  ENCODED=$(echo $ENCODE_RESPONSE | jq -r '.encoded')

                  # Test decode endpoint
                  DECODE_RESPONSE=$(curl -sf -X POST http://localhost:8000/api/v1/decode \
                    -H "Content-Type: application/json" \
                    -d "{\"encoded\": \"$ENCODED\"}")
                  echo "Decode response: $DECODE_RESPONSE"

                  # Verify roundtrip
                  DECODED_TEXT=$(echo $DECODE_RESPONSE | jq -r '.text')
                  if [ "$DECODED_TEXT" = "Hello, ΣLANG!" ]; then
                    echo "✓ Roundtrip encoding/decoding successful"
                  else
                    echo "✗ Roundtrip failed: got '$DECODED_TEXT'"
                    exit 1
                  fi

            - name: Cleanup
              if: always()
              run: |
                  docker stop $(docker ps -q) 2>/dev/null || true
                  docker rm $(docker ps -aq) 2>/dev/null || true

    # Docker Compose integration tests
    integration:
        runs-on: ubuntu-latest
        needs: build
        if: github.event_name != 'pull_request'

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4

            - name: Start services with Docker Compose
              run: |
                  # Use the built image
                  export SIGMALANG_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-$(echo ${{ github.sha }} | cut -c1-7)"

                  # Start all services
                  docker compose -f docker-compose.yml up -d

                  # Wait for services to be healthy
                  echo "Waiting for services to be healthy..."
                  sleep 15

            - name: Verify all services running
              run: |
                  # Check sigmalang API
                  curl -sf http://localhost:8000/health | jq .

                  # Check Prometheus
                  curl -sf http://localhost:9090/-/healthy

                  # Check Grafana
                  curl -sf http://localhost:3000/api/health | jq .

            - name: Run integration tests
              run: |
                  # Test API with Redis caching
                  for i in $(seq 1 5); do
                    curl -sf -X POST http://localhost:8000/api/v1/encode \
                      -H "Content-Type: application/json" \
                      -d '{"text": "Integration test '"$i"'"}' > /dev/null
                  done

                  # Verify metrics are being collected
                  curl -sf http://localhost:8000/metrics | grep -q "sigmalang_"
                  echo "✓ Metrics are being exported"

                  # Verify Prometheus is scraping
                  curl -sf "http://localhost:9090/api/v1/query?query=up" | jq .
                  echo "✓ Prometheus is scraping metrics"

            - name: Collect logs on failure
              if: failure()
              run: |
                  docker compose logs

            - name: Cleanup
              if: always()
              run: |
                  docker compose down -v

    # Security scan
    security:
        runs-on: ubuntu-latest
        needs: build
        if: github.event_name != 'pull_request'

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4

            - name: Run Trivy vulnerability scanner
              uses: aquasecurity/trivy-action@master
              with:
                  image-ref: "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-${{ github.sha }}"
                  format: "sarif"
                  output: "trivy-results.sarif"
                  severity: "CRITICAL,HIGH"
                  exit-code: "0" # Don't fail on vulnerabilities (warn only)

            - name: Upload Trivy scan results
              uses: github/codeql-action/upload-sarif@v3
              if: always()
              with:
                  sarif_file: "trivy-results.sarif"

    # Notify on completion
    notify:
        runs-on: ubuntu-latest
        needs: [build, test, integration, security]
        if: always() && github.event_name != 'pull_request'

        steps:
            - name: Check job results
              run: |
                  echo "Build: ${{ needs.build.result }}"
                  echo "Test: ${{ needs.test.result }}"
                  echo "Integration: ${{ needs.integration.result }}"
                  echo "Security: ${{ needs.security.result }}"

                  if [ "${{ needs.build.result }}" = "success" ]; then
                    echo "✓ Docker image built and pushed successfully"
                    echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
                    echo "Tags: ${{ needs.build.outputs.image-tags }}"
                  fi
